{"version":3,"sources":["reducers/pointReducer.js","reducers/distanceReducer.js","reducers/index.js","hook.js","App.js","actions/index.js","serviceWorker.js","index.js"],"names":["initialState","allPoints","mapPoint","pointReducer","state","action","type","console","log","payload","newObj","distanceReducer","distance","combineReducers","useEffectSkipInitialRender","callback","dataArr","isInitialRender","useRef","useEffect","current","App","useState","width","height","latitude","longitude","zoom","viewport","setViewport","lineCoordinates","setLineCoordinates","dispatch","useDispatch","points","useSelector","totalDistance","featuresArray","geometry","coordinates","map","single","push","geojson","features","length","turf","className","mapboxApiAccessToken","process","mapStyle","onClick","e","coord","selectedCoordinates","lngLat","mapClick","onViewportChange","nextViewport","id","data","source","paint","filter","layout","toFixed","container","document","querySelector","Boolean","window","location","hostname","match","store","createStore","rootReducer","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.13200def.chunk.js","sourcesContent":["const initialState = {\r\n\tallPoints: [],\r\n\tmapPoint: [],\r\n};\r\n\r\nexport const pointReducer = (state = initialState, action) => {\r\n\tswitch (action.type) {\r\n\t\tcase 'ADD_POINT':\r\n\t\t\tconsole.log('Selected coordinates', action.payload);\r\n\t\t\treturn {\r\n\t\t\t\t...state,\r\n\t\t\t\tallPoints: [...state.allPoints, action.payload],\r\n\t\t\t\tmapPoint: [...state.mapPoint, action.newObj],\r\n\t\t\t};\r\n\t\tdefault:\r\n\t\t\treturn state;\r\n\t}\r\n};\r\n\r\nexport default pointReducer;\r\n","export const distanceReducer = (state = '', action) => {\r\n\tswitch (action.type) {\r\n\t\tcase 'MEASURE_DISTANCE':\r\n\t\t\tconsole.log('Current distance', action.payload);\r\n\t\t\treturn { ...state, distance: action.payload };\r\n\t\tdefault:\r\n\t\t\treturn state;\r\n\t}\r\n};\r\n\r\nexport default distanceReducer;\r\n","import { combineReducers } from 'redux';\r\nimport pointReducer from './pointReducer';\r\nimport distanceReducer from './distanceReducer';\r\n\r\nexport default combineReducers({\r\n\tpointReducer,\r\n\tdistanceReducer,\r\n});\r\n","import { useEffect, useRef } from 'react';\r\n\r\nconst useEffectSkipInitialRender = (callback, dataArr) => {\r\n\tconst isInitialRender = useRef(true);\r\n\r\n\tuseEffect(() => {\r\n\t\tif (isInitialRender.current) {\r\n\t\t\tisInitialRender.current = false;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\treturn callback();\r\n\t}, dataArr);\r\n};\r\n\r\nexport default useEffectSkipInitialRender;\r\n","import React, { useState } from 'react';\nimport ReactMapGL, { FullscreenControl, Source, Layer } from 'react-map-gl';\nimport { useDispatch, useSelector } from 'react-redux';\n\n//Importing distance calculator lib\nimport * as turf from '@turf/turf';\n\nimport { addPoint, measureDistance } from './actions/index';\nimport useEffectSkipInitialRender from './hook';\nimport './App.css';\n\n//Importing required mapbox-gl styles\nimport 'mapbox-gl/dist/mapbox-gl.css';\n\nfunction App() {\n\t//Initial settings for map view\n\tconst [viewport, setViewport] = useState({\n\t\twidth: '100wv',\n\t\theight: '100vh',\n\t\tlatitude: 54.685297,\n\t\tlongitude: 25.287274,\n\t\tzoom: 12,\n\t});\n\n\t//All of the selected points coordinates\n\tconst [lineCoordinates, setLineCoordinates] = useState('');\n\n\tconst dispatch = useDispatch();\n\tconst points = useSelector((state) => state.pointReducer);\n\n\t//Receiving calculated distance from redux\n\tconst totalDistance = useSelector((state) => state.distanceReducer.distance);\n\n\t//This array is filled with data from redux, then via map --> push() methods inserted in geojson\n\tlet featuresArray = [\n\t\t{\n\t\t\ttype: 'Feature',\n\t\t\tgeometry: {\n\t\t\t\ttype: 'LineString',\n\t\t\t\tcoordinates: lineCoordinates,\n\t\t\t},\n\t\t},\n\t];\n\n\tpoints.mapPoint.map((single) => featuresArray.push(single));\n\n\tlet geojson = {\n\t\ttype: 'FeatureCollection',\n\t\tfeatures: featuresArray,\n\t};\n\n\t//If theres more than one point on the map, calculations of distance are sent to redux\n\tif (geojson.features[0].geometry.coordinates.length > 1) {\n\t\tdispatch(measureDistance(turf.length(geojson.features[0])));\n\t}\n\n\t// This custom hook skips initial execution of useEffect\n\tuseEffectSkipInitialRender(() => {\n\t\tsetLineCoordinates(points.allPoints);\n\t\treturn;\n\t}, [points]);\n\n\t//This function sends coordinates that user clicked on\n\tconst mapClick = (e) => {\n\t\tconst selectedCoordinates = [e.lngLat[0], e.lngLat[1]];\n\t\tdispatch(addPoint(selectedCoordinates));\n\t};\n\treturn (\n\t\t<div className=\"mapContainer\">\n\t\t\t<ReactMapGL\n\t\t\t\t{...viewport}\n\t\t\t\tmapboxApiAccessToken={process.env.REACT_APP_MAPBOX_TOKEN}\n\t\t\t\tmapStyle=\"mapbox://styles/mopixels/ckfmbcvun0jhk19nkgbh79tow\"\n\t\t\t\tonClick={(e) => mapClick(e)}\n\t\t\t\tonViewportChange={(nextViewport) => {\n\t\t\t\t\tsetViewport({\n\t\t\t\t\t\t...viewport,\n\t\t\t\t\t\tlatitude: nextViewport.latitude,\n\t\t\t\t\t\tlongitude: nextViewport.longitude,\n\t\t\t\t\t\tzoom: nextViewport.zoom,\n\t\t\t\t\t});\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t<Source id=\"point\" type=\"geojson\" data={geojson}>\n\t\t\t\t\t<Layer\n\t\t\t\t\t\tid=\"measure-points\"\n\t\t\t\t\t\ttype=\"circle\"\n\t\t\t\t\t\tsource=\"geojson\"\n\t\t\t\t\t\tpaint={{\n\t\t\t\t\t\t\t'circle-radius': 5,\n\t\t\t\t\t\t\t'circle-color': '#000',\n\t\t\t\t\t\t}}\n\t\t\t\t\t\tfilter={['in', '$type', 'Point']}\n\t\t\t\t\t/>\n\t\t\t\t\t<Layer\n\t\t\t\t\t\tid=\"measure-lines\"\n\t\t\t\t\t\ttype=\"line\"\n\t\t\t\t\t\tsource=\"geojson\"\n\t\t\t\t\t\tlayout={{\n\t\t\t\t\t\t\t'line-cap': 'round',\n\t\t\t\t\t\t\t'line-join': 'round',\n\t\t\t\t\t\t}}\n\t\t\t\t\t\tpaint={{\n\t\t\t\t\t\t\t'line-color': '#000',\n\t\t\t\t\t\t\t'line-width': 3.5,\n\t\t\t\t\t\t}}\n\t\t\t\t\t\tfilter={['in', '$type', 'LineString']}\n\t\t\t\t\t/>\n\t\t\t\t</Source>\n\t\t\t\t{totalDistance > 0 && (\n\t\t\t\t\t<div className=\"distance-container\">\n\t\t\t\t\t\tTotal distance: {totalDistance.toFixed(2)} km\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t\t</ReactMapGL>\n\t\t\t<div className=\"fullScreenButton\">\n\t\t\t\t<FullscreenControl container={document.querySelector('body')} />\n\t\t\t</div>\n\t\t</div>\n\t);\n}\n\nexport default App;\n","export const addPoint = (coord) => ({\r\n\ttype: 'ADD_POINT',\r\n\tpayload: coord,\r\n\tnewObj: {\r\n\t\ttype: 'Feature',\r\n\t\tgeometry: {\r\n\t\t\ttype: 'Point',\r\n\t\t\tcoordinates: coord,\r\n\t\t},\r\n\t},\r\n});\r\n\r\nexport const measureDistance = (length) => ({\r\n\ttype: 'MEASURE_DISTANCE',\r\n\tpayload: length,\r\n});\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { createStore } from 'redux';\nimport rootReducer from './reducers';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nconst store = createStore(rootReducer);\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<Provider store={store}>\n\t\t\t<App />\n\t\t</Provider>\n\t</React.StrictMode>,\n\tdocument.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}